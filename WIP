/*
fn configure(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole, title: &'static str, start_with: Configuration) -> Result<Configuration> {
    let mut configuration = start_with.clone();
    let mut print_help = true;
    'configuring:
    loop {
        if print_help {
            println!("{}

help: ... Print this help menu.
group: .. Set the PaxosID of the configuration.
epoch: .. Set the epoch of the configuration.
slot: ... Set the starting slot of the configuration.
alpha: .. Set the alpha value for the configuration.
add: .... Add a replica.  It is an error to add the same ID twice.
rm: ..... Remove a replica.  It is an error to remove a replica the doesn't exist.
print: .. Print the configuration.
save: ... Commit changes to the configuration and return to previous menu.
", title);
            print_help = false;
        }
        if options.radio_protocol {
            println!("\nOVER");
        }
        let line: &str = &unwrap_readline(rl.readline(PROMPT));
        let cmd: Vec<_> = line.split_whitespace().collect();
        if cmd.is_empty() {
            continue 'configuring;
        }
        match cmd[0] {
            "help" => {
                print_help = true;
            },
            "group" => {
                if cmd.len() != 2 {
                    println!("USAGE: group [group_id]");
                } else if cmd[1] == "auto" {
                    let mut bytes: [u8; one_two_eight::BYTES] = [0u8; one_two_eight::BYTES];
                    guac.fill(&mut bytes);
                    let group = PaxosID {
                        id: bytes,
                    };
                    configuration.group = group;
                } else if let Some(group) = PaxosID::from_human_readable(cmd[1]) {
                    configuration.group = group;
                } else {
                    println!("invalid group_id");
                }
            },
            "epoch" => {
                if cmd.len() != 2 {
                    println!("USAGE: epoch [epoch]");
                } else if let Ok(epoch) = cmd[1].parse::<u64>() {
                    configuration.epoch = epoch;
                } else {
                    println!("invalid epoch");
                }
            },
            "slot" => {
                if cmd.len() != 2 {
                    println!("USAGE: slot [slot]");
                } else if let Ok(slot) = cmd[1].parse::<u64>() {
                    configuration.first_slot = slot;
                } else {
                    println!("invalid slot");
                }
            },
            "alpha" => {
                if cmd.len() != 2 {
                    println!("USAGE: alpha [alpha]");
                } else if let Ok(alpha) = cmd[1].parse::<u64>() {
                    if (paxos_pb::MIN_ALPHA..=paxos_pb::MAX_ALPHA).contains(&alpha) {
                        configuration.alpha = alpha;
                    } else {
                        println!("invalid alpha");
                    }
                } else {
                    println!("invalid alpha");
                }
            },
            "add" => {
                if cmd.len() != 2 {
                    println!("USAGE: add [replica]");
                } else if cmd[1] == "auto" {
                    let mut bytes: [u8; one_two_eight::BYTES] = [0u8; one_two_eight::BYTES];
                    guac.fill(&mut bytes);
                    let replica = ReplicaID {
                        id: bytes,
                    };
                    if configuration.is_replica(replica) {
                        println!("replica already added");
                    } else {
                        configuration.replicas.push(replica);
                    }
                } else if let Some(replica) = ReplicaID::from_human_readable(cmd[1]) {
                    if configuration.is_replica(replica) {
                        println!("replica already added");
                    } else {
                        configuration.replicas.push(replica);
                    }
                } else {
                    println!("invalid replica");
                }
            },
            "rm" => {
                if cmd.len() != 2 {
                    println!("USAGE: rm [replica]");
                } else if let Some(replica) = ReplicaID::from_human_readable(cmd[1]) {
                    let mut idx = None;
                    for (i, r) in configuration.replicas.iter().enumerate() {
                        if *r == replica {
                            idx = Some(i);
                        }
                    }
                    if let Some(idx) = idx {
                        configuration.replicas.remove(idx);
                    } else {
                        println!("unknown replica");
                    }
                } else {
                    println!("invalid replica");
                }
            },
            "print" => {
                println!("{:#?}", configuration);
            },
            "save" => {
                return Ok(configuration);
            },
            _ => {
                handle_unknown_command(line);
            },
        }
    }
}

fn steady_state(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole, mut config: Configuration) -> Result<()> {
    let mut print_help = true;
    'configuring:
    loop {
        if print_help {
            println!("Steady-State

help: ......... Print this help menu.
seed: ......... Seed the guacamole (would that be a pit?).
reconfigure: .. Reconfigure the cluster.
");
            print_help = false;
        }
        if options.radio_protocol {
            println!("\nOVER");
        }
        let line: &str = &unwrap_readline(rl.readline(PROMPT));
        let cmd: Vec<_> = line.split_whitespace().collect();
        if cmd.is_empty() {
            continue 'configuring;
        }
        match cmd[0] {
            "help" => {
                print_help = true;
            },
            "seed" => {
                if cmd.len() != 2 {
                    println!("USAGE: seed [value]");
                } else {
                    match cmd[1].parse::<u64>() {
                        Ok(seed) => {
                            guac.seek(seed);
                        },
                        Err(err) => {
                            println!("USAGE: seed [value]");
                            println!("value must be unsigned integer: {}", err);
                        },
                    };
                }
            }
            "reconfigure" => {
                let new_config = configure(options, rl, guac, "Reconfigure Cluster", config)?;
                config = new_config;
            },
            _ => {
                handle_unknown_command(line);
            },
        }
    }
}
*/
#
#
#
#[cfg(test)]
pub mod testutil {
    use super::Ballot;

    pub use crate::configuration::testutil::*;

    pub const BALLOT_4_REPLICA1: Ballot = Ballot {
        number: 4,
        leader: REPLICA1,
    };

    pub const BALLOT_5_REPLICA1: Ballot = Ballot {
        number: 5,
        leader: REPLICA1,
    };

    pub const BALLOT_6_REPLICA1: Ballot = Ballot {
        number: 6,
        leader: REPLICA1,
    };

    pub const BALLOT_6_REPLICA2: Ballot = Ballot {
        number: 6,
        leader: REPLICA2,
    };

    pub const BALLOT_7_REPLICA1: Ballot = Ballot {
        number: 7,
        leader: REPLICA1,
    };
}

#[cfg(test)]
mod tests {
    use super::testutil::*;
    use super::*;

    // Test the ballot basics
    #[test]
    fn ballot_getters() {
        assert_eq!(BALLOT_5_REPLICA1.number(), 5);
        assert_eq!(BALLOT_5_REPLICA1.leader(), REPLICA1);
    }

    // Test that the Ballot string looks like what we expect.
    #[test]
    fn ballot_string() {
        assert_eq!(
            BALLOT_5_REPLICA1.to_string(),
            "ballot:5:aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
        );
    }

    // Test that ballots are ordered first by their number and then by their leader.
    #[test]
    fn ballot_order() {
        assert!(Ballot::BOTTOM < BALLOT_5_REPLICA1);
        assert!(BALLOT_5_REPLICA1 < BALLOT_6_REPLICA1);
        assert!(BALLOT_6_REPLICA1 < BALLOT_6_REPLICA2);
        assert!(BALLOT_6_REPLICA2 < BALLOT_7_REPLICA1);
        assert!(BALLOT_7_REPLICA1 < Ballot::TOP);
    }

    // Test the PValue basics
    #[test]
    fn pvalue_basics() {
        let pval = PValue::new(32, BALLOT_5_REPLICA1, Command::data("command"));
        assert_eq!(pval.slot(), 32);
        assert_eq!(pval.ballot(), BALLOT_5_REPLICA1);
        assert_eq!(pval.command(), &Command::data("command"));
    }

    // Test that the PValue string looks like what we expect.
    #[test]
    fn pvalue_string() {
        let pval = PValue::new(32, BALLOT_5_REPLICA1, Command::data("command"));
        assert_eq!(
            pval.to_string(),
            "pvalue:32:5:aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
        );
    }

    // Test that ballots are ordered first by their number and then by their leader.
    #[test]
    fn pvalue_order() {
        let pval1 = PValue::new(1, BALLOT_7_REPLICA1, Command::data("command7"));
        let pval2 = PValue::new(2, BALLOT_6_REPLICA2, Command::data("command6"));
        let pval3 = PValue::new(3, BALLOT_6_REPLICA1, Command::data("command6"));
        let pval4 = PValue::new(4, BALLOT_5_REPLICA1, Command::data("command5"));
        let pval5 = PValue::new(5, BALLOT_4_REPLICA1, Command::data("command4"));

        assert!(pval1 < pval2);
        assert!(pval2 < pval3);
        assert!(pval3 < pval4);
        assert!(pval4 < pval5);
    }
}


/*
///////////////////////////////////////////// Configure ////////////////////////////////////////////

const CONFIGURE_HELP: &str = "Configuration:

help: ... Print this help menu.
group: .. Set the PaxosID of the configuration.
epoch: .. Set the epoch of the configuration.
slot: ... Set the starting slot of the configuration.
alpha: .. Set the alpha value for the configuration.
add: .... Add a replica.  It is an error to add the same ID twice.
rm: ..... Remove a replica.  It is an error to remove a replica the doesn't exist.
print: .. Print the configuration.
save: ... Commit changes to the configuration and return to previous menu.
";

fn configure<H: Harness>(_: &ShellOptions, harness: &mut H, guac: &mut Guacamole, configuration: &mut Configuration) -> Result<(), Error> {
    let mut print_help = true;
    'configuring:
    loop {
        if print_help {
            writeln!(harness, "{}", CONFIGURE_HELP)?;
            print_help = false;
        }
        if let Some(ref line) = harness.next_command() {
            let cmd: Vec<_> = line.split_whitespace().collect();
            if cmd.is_empty() {
                continue 'configuring;
            }
            match cmd[0] {
                "help" => {
                    print_help = true;
                },
                "group" => {
                    if cmd.len() != 2 {
                        writeln!(harness, "USAGE: group [group_id]")?;
                    } else if cmd[1] == "auto" {
                        let mut bytes: [u8; one_two_eight::BYTES] = [0u8; one_two_eight::BYTES];
                        guac.fill(&mut bytes);
                        let group = PaxosID {
                            id: bytes,
                        };
                        configuration.group = group;
                    } else if let Some(group) = PaxosID::from_human_readable(cmd[1]) {
                        configuration.group = group;
                    } else {
                        writeln!(harness, "invalid group_id")?;
                    }
                },
                "epoch" => {
                    if cmd.len() != 2 {
                        writeln!(harness, "USAGE: epoch [epoch]")?;
                    } else if let Ok(epoch) = cmd[1].parse::<u64>() {
                        configuration.epoch = epoch;
                    } else {
                        writeln!(harness, "invalid epoch")?;
                    }
                },
                "slot" => {
                    if cmd.len() != 2 {
                        writeln!(harness, "USAGE: slot [slot]")?;
                    } else if let Ok(slot) = cmd[1].parse::<u64>() {
                        configuration.first_slot = slot;
                    } else {
                        writeln!(harness, "invalid slot")?;
                    }
                },
                "alpha" => {
                    if cmd.len() != 2 {
                        writeln!(harness, "USAGE: alpha [alpha]")?;
                    } else if let Ok(alpha) = cmd[1].parse::<u64>() {
                        if (super::MIN_ALPHA..=super::MAX_ALPHA).contains(&alpha) {
                            configuration.alpha = alpha;
                        } else {
                            writeln!(harness, "invalid alpha")?;
                        }
                    } else {
                        writeln!(harness, "invalid alpha")?;
                    }
                },
                "add" => {
                    if cmd.len() != 2 {
                        writeln!(harness, "USAGE: add [replica]")?;
                    } else if cmd[1] == "auto" {
                        let mut bytes: [u8; one_two_eight::BYTES] = [0u8; one_two_eight::BYTES];
                        guac.fill(&mut bytes);
                        let replica = ReplicaID {
                            id: bytes,
                        };
                        if configuration.is_replica(replica) {
                            writeln!(harness, "replica already added")?;
                        } else {
                            configuration.replicas.push(replica);
                        }
                    } else if let Some(replica) = ReplicaID::from_human_readable(cmd[1]) {
                        if configuration.is_replica(replica) {
                            writeln!(harness, "replica already added")?;
                        } else {
                            configuration.replicas.push(replica);
                        }
                    } else {
                        writeln!(harness, "invalid replica")?;
                    }
                },
                "rm" => {
                    if cmd.len() != 2 {
                        writeln!(harness, "USAGE: rm [replica]")?;
                    } else if let Some(replica) = ReplicaID::from_human_readable(cmd[1]) {
                        let mut idx = None;
                        for (i, r) in configuration.replicas.iter().enumerate() {
                            if *r == replica {
                                idx = Some(i);
                            }
                        }
                        if let Some(idx) = idx {
                            configuration.replicas.remove(idx);
                        } else {
                            writeln!(harness, "unknown replica")?;
                        }
                    } else {
                        writeln!(harness, "invalid replica")?;
                    }
                },
                "print" => {
                    writeln!(harness, "{:#?}", configuration)?;
                },
                "save" => {
                    break 'configuring;
                },
                _ => {
                    writeln!(harness, "unknown command: {}", line.as_str())?;
                },
            }
        } else {
            break 'configuring;
        }
    }
    Ok(())
}

/////////////////////////////////////////// Steady State ///////////////////////////////////////////

const STEADY_STATE_HELP: &str = "Steady-State Operation.

help: ......... Print this help menu.
seed: ......... Seed the guacamole (would that be a pit?).
reconfigure: .. Reconfigure the cluster.
";

fn steady_state<H: Harness>(options: &ShellOptions, harness: &mut H, guac: &mut Guacamole, mut configuration: Configuration) -> Result<(), Error> {
    let mut print_help = true;
    'adventuring:
    loop {
        if print_help {
            writeln!(harness, "{}", STEADY_STATE_HELP)?;
            print_help = false;
        }
        if let Some(ref line) = harness.next_command() {
            let cmd: Vec<_> = line.split_whitespace().collect();
            if cmd.is_empty() {
                continue 'adventuring;
            }
            match cmd[0] {
                "help" => {
                    print_help = true;
                },
                "seed" => {
                    if cmd.len() != 2 {
                        writeln!(harness, "USAGE: seed [value]")?;
                    } else {
                        match cmd[1].parse::<u64>() {
                            Ok(seed) => {
                                guac.seek(seed);
                            },
                            Err(err) => {
                                writeln!(harness, "value must be unsigned integer: {}", err)?;
                            },
                        };
                    }
                },
                "reconfigure" => {
                    let mut new_config = configuration.clone();
                    configure(options, harness, guac, &mut new_config)?;
                    configuration = new_config;
                },
                _ => {
                    writeln!(harness, "unknown command: {}", line.as_str())?;
                },
            }
        } else {
            break 'adventuring;
        }
    }
    Ok(())
}

            _ => {
                handle_unknown_command(line);
            },
        }
    }
}


impl Default for Options {
    fn default() -> Self {
        Options {
            radio_protocol: false,
        }
    }
}

fn main() -> Result<()> {
    let (options, free) = Options::from_command_line_relaxed();
    if !free.is_empty() {
        panic!("command takes no positional arguments");
    }
    let config = Config::builder()
        .max_history_size(1_000_000)?
        .history_ignore_dups(true)?
        .history_ignore_space(true)
        .build();
    let hist = MemHistory::new();
    let mut rl = Editor::with_history(config, hist)?;

    // Run the welcome menu to start the session.
    let mut guac = Guacamole::default();
    welcome(&options, &mut rl, &mut guac)
}

/*
fn welcome(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole) -> Result<()> {
fn steady_state(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole, mut config: Configuration) -> Result<()> {
fn configure(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole, title: &'static str, start_with: Configuration) -> Result<Configuration> {

*/

fn configure(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole, title: &'static str, start_with: Configuration) -> Result<Configuration> {
    /*
    let mut configuration = start_with.clone();
    let mut print_help = true;
    'configuring:
    loop {
        if print_help {
            println!("{}

help: ... Print this help menu.
group: .. Set the PaxosID of the configuration.
epoch: .. Set the epoch of the configuration.
slot: ... Set the starting slot of the configuration.
alpha: .. Set the alpha value for the configuration.
add: .... Add a replica.  It is an error to add the same ID twice.
rm: ..... Remove a replica.  It is an error to remove a replica the doesn't exist.
print: .. Print the configuration.
save: ... Commit changes to the configuration and return to previous menu.
", title);
            print_help = false;
        }
        if options.radio_protocol {
            println!("\nOVER");
        }
        let line: &str = &unwrap_readline(rl.readline(PROMPT));
        let cmd: Vec<_> = line.split_whitespace().collect();
        if cmd.is_empty() {
            continue 'configuring;
        }
        match cmd[0] {
            "help" => {
                print_help = true;
            },
            "group" => {
                if cmd.len() != 2 {
                    println!("USAGE: group [group_id]");
                } else if cmd[1] == "auto" {
                    let mut bytes: [u8; one_two_eight::BYTES] = [0u8; one_two_eight::BYTES];
                    guac.fill(&mut bytes);
                    let group = PaxosID {
                        id: bytes,
                    };
                    configuration.group = group;
                } else if let Some(group) = PaxosID::from_human_readable(cmd[1]) {
                    configuration.group = group;
                } else {
                    println!("invalid group_id");
                }
            },
            "epoch" => {
                if cmd.len() != 2 {
                    println!("USAGE: epoch [epoch]");
                } else if let Ok(epoch) = cmd[1].parse::<u64>() {
                    configuration.epoch = epoch;
                } else {
                    println!("invalid epoch");
                }
            },
            "slot" => {
                if cmd.len() != 2 {
                    println!("USAGE: slot [slot]");
                } else if let Ok(slot) = cmd[1].parse::<u64>() {
                    configuration.first_slot = slot;
                } else {
                    println!("invalid slot");
                }
            },
            "alpha" => {
                if cmd.len() != 2 {
                    println!("USAGE: alpha [alpha]");
                } else if let Ok(alpha) = cmd[1].parse::<u64>() {
                    if (paxos_pb::MIN_ALPHA..=paxos_pb::MAX_ALPHA).contains(&alpha) {
                        configuration.alpha = alpha;
                    } else {
                        println!("invalid alpha");
                    }
                } else {
                    println!("invalid alpha");
                }
            },
            "add" => {
                if cmd.len() != 2 {
                    println!("USAGE: add [replica]");
                } else if cmd[1] == "auto" {
                    let mut bytes: [u8; one_two_eight::BYTES] = [0u8; one_two_eight::BYTES];
                    guac.fill(&mut bytes);
                    let replica = ReplicaID {
                        id: bytes,
                    };
                    if configuration.is_replica(replica) {
                        println!("replica already added");
                    } else {
                        configuration.replicas.push(replica);
                    }
                } else if let Some(replica) = ReplicaID::from_human_readable(cmd[1]) {
                    if configuration.is_replica(replica) {
                        println!("replica already added");
                    } else {
                        configuration.replicas.push(replica);
                    }
                } else {
                    println!("invalid replica");
                }
            },
            "rm" => {
                if cmd.len() != 2 {
                    println!("USAGE: rm [replica]");
                } else if let Some(replica) = ReplicaID::from_human_readable(cmd[1]) {
                    let mut idx = None;
                    for (i, r) in configuration.replicas.iter().enumerate() {
                        if *r == replica {
                            idx = Some(i);
                        }
                    }
                    if let Some(idx) = idx {
                        configuration.replicas.remove(idx);
                    } else {
                        println!("unknown replica");
                    }
                } else {
                    println!("invalid replica");
                }
            },
            "print" => {
                println!("{:#?}", configuration);
            },
            "save" => {
                return Ok(configuration);
            },
            _ => {
                handle_unknown_command(line);
            },
        }
    }
    */
}

/*
#[macro_use]
extern crate arrrg_derive;

use rand::Rng;

use rustyline::error::ReadlineError;
use rustyline::history::MemHistory;
use rustyline::{Config, Editor, Result};

use guacamole::Guacamole;

use arrrg::CommandLine;

use paxos_pb::{Configuration, PaxosID, ReplicaID};

const PROMPT: &str = "> ";

fn handle_ctrl_c() -> ! {
    std::process::exit(1);
}

fn handle_eof() -> ! {
    std::process::exit(0);
}

fn handle_unknown_command(line: &str) {
    println!("unknown command: {}", line);
}

fn unwrap_readline(line: Result<String>) -> String {
    match line {
        Ok(line) => {
            line.trim().to_owned()
        },
        Err(ReadlineError::Interrupted) => {
            handle_ctrl_c();
        },
        Err(ReadlineError::Eof) => {
            handle_eof();
        },
        Err(err) => {
            panic!("could not read line: {}", err);
        },
    }
}

const WELCOME_HELP: &str = "Welcome to paxos-shell.  The following options are available:

help: ....... Print this help menu.
configure: .. Configure a new cluster to bootstrap the simulation.
begin: ...... Start the simulation with the provided cluster.
";

fn welcome(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole) -> Result<()> {
    let mut configuration = Configuration::default();
    let mut print_help = true;
    loop {
        if print_help {
            println!("{}", WELCOME_HELP);
            print_help = false;
        }
        if options.radio_protocol {
            println!("\nOVER");
        }
        let line: &str = &unwrap_readline(rl.readline(PROMPT));
        match line {
            "help" => {
                print_help = true;
            },
            "configure" => {
                configuration = configure(options, rl, guac, "Initial Configuration", configuration)?;
            },
            "begin" => {
                return steady_state(options, rl, guac, configuration);
            },
            _ => {
                handle_unknown_command(line);
            },
        }
    }
}

fn configure(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole, title: &'static str, start_with: Configuration) -> Result<Configuration> {
    let mut configuration = start_with.clone();
    let mut print_help = true;
    'configuring:
    loop {
        if print_help {
            println!("{}

help: ... Print this help menu.
group: .. Set the PaxosID of the configuration.
epoch: .. Set the epoch of the configuration.
slot: ... Set the starting slot of the configuration.
alpha: .. Set the alpha value for the configuration.
add: .... Add a replica.  It is an error to add the same ID twice.
rm: ..... Remove a replica.  It is an error to remove a replica the doesn't exist.
print: .. Print the configuration.
save: ... Commit changes to the configuration and return to previous menu.
", title);
            print_help = false;
        }
        if options.radio_protocol {
            println!("\nOVER");
        }
        let line: &str = &unwrap_readline(rl.readline(PROMPT));
        let cmd: Vec<_> = line.split_whitespace().collect();
        if cmd.is_empty() {
            continue 'configuring;
        }
        match cmd[0] {
            "help" => {
                print_help = true;
            },
            "group" => {
                if cmd.len() != 2 {
                    println!("USAGE: group [group_id]");
                } else if cmd[1] == "auto" {
                    let mut bytes: [u8; one_two_eight::BYTES] = [0u8; one_two_eight::BYTES];
                    guac.fill(&mut bytes);
                    let group = PaxosID {
                        id: bytes,
                    };
                    configuration.group = group;
                } else if let Some(group) = PaxosID::from_human_readable(cmd[1]) {
                    configuration.group = group;
                } else {
                    println!("invalid group_id");
                }
            },
            "epoch" => {
                if cmd.len() != 2 {
                    println!("USAGE: epoch [epoch]");
                } else if let Ok(epoch) = cmd[1].parse::<u64>() {
                    configuration.epoch = epoch;
                } else {
                    println!("invalid epoch");
                }
            },
            "slot" => {
                if cmd.len() != 2 {
                    println!("USAGE: slot [slot]");
                } else if let Ok(slot) = cmd[1].parse::<u64>() {
                    configuration.first_slot = slot;
                } else {
                    println!("invalid slot");
                }
            },
            "alpha" => {
                if cmd.len() != 2 {
                    println!("USAGE: alpha [alpha]");
                } else if let Ok(alpha) = cmd[1].parse::<u64>() {
                    if (paxos_pb::MIN_ALPHA..=paxos_pb::MAX_ALPHA).contains(&alpha) {
                        configuration.alpha = alpha;
                    } else {
                        println!("invalid alpha");
                    }
                } else {
                    println!("invalid alpha");
                }
            },
            "add" => {
                if cmd.len() != 2 {
                    println!("USAGE: add [replica]");
                } else if cmd[1] == "auto" {
                    let mut bytes: [u8; one_two_eight::BYTES] = [0u8; one_two_eight::BYTES];
                    guac.fill(&mut bytes);
                    let replica = ReplicaID {
                        id: bytes,
                    };
                    if configuration.is_replica(replica) {
                        println!("replica already added");
                    } else {
                        configuration.replicas.push(replica);
                    }
                } else if let Some(replica) = ReplicaID::from_human_readable(cmd[1]) {
                    if configuration.is_replica(replica) {
                        println!("replica already added");
                    } else {
                        configuration.replicas.push(replica);
                    }
                } else {
                    println!("invalid replica");
                }
            },
            "rm" => {
                if cmd.len() != 2 {
                    println!("USAGE: rm [replica]");
                } else if let Some(replica) = ReplicaID::from_human_readable(cmd[1]) {
                    let mut idx = None;
                    for (i, r) in configuration.replicas.iter().enumerate() {
                        if *r == replica {
                            idx = Some(i);
                        }
                    }
                    if let Some(idx) = idx {
                        configuration.replicas.remove(idx);
                    } else {
                        println!("unknown replica");
                    }
                } else {
                    println!("invalid replica");
                }
            },
            "print" => {
                println!("{:#?}", configuration);
            },
            "save" => {
                return Ok(configuration);
            },
            _ => {
                handle_unknown_command(line);
            },
        }
    }
}

fn steady_state(options: &Options, rl: &mut Editor<(), MemHistory>, guac: &mut Guacamole, mut config: Configuration) -> Result<()> {
    let mut print_help = true;
    'configuring:
    loop {
        if print_help {
            println!("Steady-State

help: ......... Print this help menu.
seed: ......... Seed the guacamole (would that be a pit?).
reconfigure: .. Reconfigure the cluster.
");
            print_help = false;
        }
        if options.radio_protocol {
            println!("\nOVER");
        }
        let line: &str = &unwrap_readline(rl.readline(PROMPT));
        let cmd: Vec<_> = line.split_whitespace().collect();
        if cmd.is_empty() {
            continue 'configuring;
        }
        match cmd[0] {
            "help" => {
                print_help = true;
            },
            "seed" => {
                if cmd.len() != 2 {
                    println!("USAGE: seed [value]");
                } else {
                    match cmd[1].parse::<u64>() {
                        Ok(seed) => {
                            guac.seek(seed);
                        },
                        Err(err) => {
                            println!("USAGE: seed [value]");
                            println!("value must be unsigned integer: {}", err);
                        },
                    };
                }
            }
            "reconfigure" => {
                let new_config = configure(options, rl, guac, "Reconfigure Cluster", config)?;
                config = new_config;
            },
            _ => {
                handle_unknown_command(line);
            },
        }
    }
}

#[derive(CommandLine, Eq, PartialEq)]
struct Options {
    #[arrrg(flag, "Print \"OVER\" after each command and before the prompt.")]
    radio_protocol: bool,
}

impl Default for Options {
    fn default() -> Self {
        Options {
            radio_protocol: false,
        }
    }
}

fn main() -> Result<()> {
    let (options, free) = Options::from_command_line_relaxed();
    if !free.is_empty() {
        panic!("command takes no positional arguments");
    }
    let config = Config::builder()
        .max_history_size(1_000_000)?
        .history_ignore_dups(true)?
        .history_ignore_space(true)
        .build();
    let hist = MemHistory::new();
    let mut rl = Editor::with_history(config, hist)?;

    // Run the welcome menu to start the session.
    let mut guac = Guacamole::default();
    welcome(&options, &mut rl, &mut guac)
}
*/
*/
